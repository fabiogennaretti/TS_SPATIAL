<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Modèles hiérarchiques bayésiens 2</title>

<script src="libs/header-attrs-2.20/header-attrs.js"></script>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/spacelab.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="libs/navigation-1.1/tabsets.js"></script>
<link href="libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div id="header">



<h1 class="title toc-ignore">Modèles hiérarchiques bayésiens 2</h1>

</div>


<div id="données" class="section level2">
<h2>Données</h2>
<div class="figure">
<img src="../images/GAB4770.jpg" alt="" />
<p class="caption">Svalbard reindeer</p>
</div>
<p>Les données proviennent de mon post-doctorat. Nous analyserons la
probabilité d’un renne d’avoir un bébé durant l’été. Dans ce système, un
des plus importants facteurs environnementaux est la présence d’épisodes
de pluie-sur-neige. Ceux-ci surviennent quand des précipitations
surviennent au cours de l’hivers. Celles-ci gèlent et forment ensuite
d’épaisse couche de glace bloquant l’accès aux ressources
alimentaires.</p>
<p>Cependant, avec le réchauffement continue de l’arctique, certain
chercheur croient que le ros n’aura plus d’effet. Quand il y a des
épisodes de pluies durables suivi d’une période chaude, la pluie cause
un dégagement des ressources alimentaires et a le temps de ruisseler
avant de geler. Nous tenterons d’explorer ces changements dans l’effet
du ros.</p>
<pre class="r"><code>library(dplyr)
library(readr)
library(ggplot2)
library(tidyr)
library(cowplot)
library(lubridate)

dat &lt;- read_csv(&quot;../donnees/SvalbardDat.csv&quot;)
dat &lt;- dat %&gt;% mutate(age=year-yrbirth) %&gt;% filter(age&gt;1)

ros &lt;- read_csv(&quot;../donnees/ROS.csv&quot;)</code></pre>
<pre class="r"><code>dat &lt;- dat %&gt;% left_join(ros) %&gt;% 
  mutate(rosNorm = scale(log(ros)),
         ages=scale(age),
         age2=ages^2,
         obsid=1:n(),
         period=cut(year,breaks = seq(1994,2020,by=5)))</code></pre>
<p>Nous transformons d’abord les prédicteurs:</p>
<ul>
<li><em>rosNorm</em> est le logarithme de <em>ros</em>, normalisé pour
avoir une moyenne de 0 et un écart-type de 1.</li>
<li><em>ages</em> est la normalisation de age pour avoir une moyenne de
0 et un écart-type de 1</li>
<li>Nous créons une variable <em>age2</em> pour l’effet quadratique de
l’âge.</li>
<li>et finalement une variable <em>période</em> qui sépare l’étude en 5
périodes</li>
</ul>
<pre class="r"><code>g1 &lt;- dat %&gt;% group_by(age) %&gt;% summarise(mc=mean(calf,na.rm=T),n()) %&gt;% 
  ggplot(aes(age,mc))+geom_point()

g2 &lt;- dat %&gt;% group_by(period,year,rosNorm) %&gt;% summarise(mc=mean(calf,na.rm=T),n()) %&gt;% 
  ggplot(aes(rosNorm,mc,color=period))+geom_point()+geom_smooth(method = lm,se=F)+guides(color=&#39;none&#39;)

plot_grid(g1,g2)</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
</div>
<div
id="modèle-bayésien-de-la-probabilité-de-reproduction-selon-lâge-et-du-ros"
class="section level2">
<h2>1. Modèle bayésien de la probabilité de reproduction selon l’âge et
du ros</h2>
<p>Bien entendu, il faudra contrôler pour l’âge des individus. Le modèle
sera donc un modèle binomial avec comme effet fixe, l’âge et son carré,
et le ros. Les effets aléatoires consisteront de l’année, la période et
une pente du ros variant selon la période.</p>
<p><em>Notes</em>:</p>
<ul>
<li><p>La formule du modèle dans <code>brm</code> suit la même syntaxe
que <code>lmer</code> pour la spécification des effets fixes et
aléatoires.</p></li>
<li><p>Bien qu’il serait possible d’ajouter l’interaction
<code>age:ros</code>, l’année, l’ID, la densité et plusieurs autres
variables contrôle. Nous les omettons ici afin de réduire le temps de
calcul des modèles.</p></li>
</ul>
<pre class="r"><code>brm(calf ~ ages+age2+rosNorm +(rosNorm|period),family=bernoulli(&quot;logit&quot;),
    prior = my_prior,iter = 4000,thin=2,
    data = dat,chains = 2)</code></pre>
<p><strong>A</strong> Choisissez des distributions <em>a priori</em>
pour les paramètres du modèle décrit ci-dessus. Voici un exemple de code
où il ne manque que la spécification des distributions. Les quatre
premières lignes définissent les distributions <em>a priori</em> pour
l’ordonnée à l’origine et les coefficients des trois effets fixes, les
trois suivantes définissent les distributions pour les écarts-types des
effets aléatoires (<code>class = "sd"</code>), tandis que la dernière
réfère à l’écart-type des observations individuelles
(<code>class = "sigma"</code>).</p>
<pre class="r"><code>library(brms)
my_prior &lt;- c(set_prior(&quot;&quot;, class = &quot;Intercept&quot;),
               set_prior(&quot;&quot;, class = &quot;b&quot;, coef = &quot;ages&quot;),
               set_prior(&quot;&quot;, class = &quot;b&quot;, coef = &quot;age2&quot;),
               set_prior(&quot;&quot;, class = &quot;b&quot;, coef = &quot;rosNorm&quot;),
               set_prior(&quot;&quot;, class = &quot;sd&quot;, coef = &quot;Intercept&quot;, group = &quot;id&quot;),
               set_prior(&quot;&quot;, class = &quot;sd&quot;, coef = &quot;Intercept&quot;, group = &quot;period&quot;),
               set_prior(&quot;&quot;, class = &quot;sd&quot;, coef = &quot;rosNorm&quot;, group = &quot;period&quot;))</code></pre>
<p>Il est recommandé de choisir des distributions normales dans tous les
cas. Pour “sd”, ces distributions seront interprétées comme des
demi-normales car il est sous-entendu que ces paramètres sont <span
class="math inline">\(\geq 0\)</span>. Pour choisir la moyenne et
l’écart-type de chaque distribution normale, considérez l’interprétation
de chaque paramètre et en particulier les échelles des prédicteurs
<code>ros</code> , <code>ages</code> et <code>age2</code>. Dans bmrs, la
famille utilisé sera <code>family=bernoulli("logit")</code>.</p>
<p>Quant aux écarts-types des effets aléatoires (“sd”), leur
distribution <em>a priori</em> peut avoir la même largeur que celle du
coefficient “b” correspondant.</p>
<pre class="r"><code>library(brms)
my_prior &lt;- c(set_prior(&quot;normal(0,1.5)&quot;, class = &quot;Intercept&quot;),
               set_prior(&quot;normal(.5,.25)&quot;, class = &quot;b&quot;, coef = &quot;ages&quot;),
               set_prior(&quot;normal(-.5,.25)&quot;, class = &quot;b&quot;, coef = &quot;age2&quot;),
               set_prior(&quot;normal(0,.5)&quot;, class = &quot;b&quot;, coef = &quot;rosNorm&quot;),
               # set_prior(&quot;normal(0,.5)&quot;, class = &quot;sd&quot;, coef = &quot;Intercept&quot;, group = &quot;id&quot;),
               set_prior(&quot;normal(0,.5)&quot;, class = &quot;sd&quot;, coef = &quot;Intercept&quot;, group = &quot;period&quot;),
               set_prior(&quot;normal(0,.5)&quot;, class = &quot;sd&quot;, coef = &quot;rosNorm&quot;, group = &quot;period&quot;))</code></pre>
<p>l’intercept sera centrer autour de 0 avec une sd=1.5. Ceci résulte en
un prior assez peut informatif sur l’échelle des probabilité. Les prior
pour l’age sont choisis pour aller d’environ 0 jusqu’à une valeur
raisonnable. celle-ci est positive pour ages et négative pour age2. Ceci
résulte en une forme de U inversé pour l’effet de l’age. Le prior pour
ros est normal(0,.5), la moyenne est peut informative (centré sur 0), la
sd=0.5 signifie que la pente pourrait aller de -1 à 1 (2*sd). Dans un
contexte de régression binomial avec des variables explicative
normalisé, une pente de 1 est considéré comme un effet fort.</p>
<p><strong>B</strong> Tirez maintenant un échantillon de la distribution
conjointe <em>a priori</em> des paramètres avec <code>brm</code>. Je
suggère de spécifier <code>chains = 1, iter = 1500, warmup = 1000</code>
pour produire une seule chaîne de Markov avec 1000 itérations de rodage
et 500 itérations d’échantillonnage. Visualisez ensuite la distribution
de <code>calf</code> prédite pour chaque itération des paramètres <em>a
priori</em>.</p>
<pre class="r"><code>res_prior &lt;- brm(calf ~ ages+age2+rosNorm +(rosNorm|period),family=bernoulli(&quot;logit&quot;),
    prior = my_prior,sample_prior = &quot;only&quot;,
    data = dat,chains = 1, iter = 3000, warmup = 1000)</code></pre>
<pre class="r"><code>prior_params &lt;- as_draws_df(res_prior) %&gt;% mutate(id=1:n())

hist(prior_params$b_Intercept) # prior sur l&#39;échelle de la fct lien</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<pre class="r"><code>hist(plogis(prior_params$b_Intercept)) # prior sur l&#39;échelle de la reponse</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-8-2.png" width="672" /></p>
<pre class="r"><code>hist(prior_params$sd_period__Intercept) </code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-8-3.png" width="672" /></p>
<pre class="r"><code># siluation de valeur reponse base
# sur les parametre simulé à partir des prior
prior_pred &lt;- posterior_predict(res_prior)
prior_df &lt;- data.frame(prior_pred)[1:200,] # en garder juste 200 pour garder leger
prior_df$sim_id &lt;- 1:nrow(prior_df)
prior_df &lt;- pivot_longer(prior_df, cols = -sim_id,
names_to = &quot;obsid&quot;, values_to = &quot;calfprior&quot;) %&gt;%
  mutate(obsid=as.numeric(substr(obsid,2,9))) #pivoter pour la manipulation
# et extraite l&#39;id de l&#39;observation (pourt un join futur)


# regardon dabord la distribution de valeurs prédite
# ceci est peu informatif puisqu&#39;il ne sagit que de 0 et de 1
ggplot(prior_df, aes(x = calfprior)) +
stat_density(aes(group = sim_id), position = &quot;identity&quot;, geom = &quot;line&quot;, alpha = 0.3) </code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-8-4.png" width="672" /></p>
<pre class="r"><code># joignon plutot les prediction a prior au donnée pour voir 
# comment cele-ci change en fct de différente var explicative
# premierement l&#39;age
# les prior semblent résulter en prédiction plus extrème que prévues
# dans ce cas, ceci est du à l&#39;effet cumulatif de l&#39;intercept et de l&#39;effets aléatoire


prior_df &lt;- prior_df %&gt;% left_join(dat)
prior_df %&gt;% ggplot(aes(x=as.factor(round(ages,2)),y=calfprior))+geom_violin()</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-8-5.png" width="672" /></p>
<pre class="r"><code># mais si nous regardont les tendence moyenne, elles ont la bonne forme
# la mojorité comment faible, augmente et sont faible pour les vielles femmelles
ggplot(prior_df,aes(x=age,y=calfprior))+
  geom_smooth(aes(group = sim_id),method=&quot;glm&quot;,formula = y~x+I(x^2),method.args = list(family=&#39;binomial&#39;),se=F,linewidth=0.2)</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-8-6.png" width="672" /></p>
<pre class="r"><code>#on peut faire le meme exercise pour le ros
ggplot(prior_df,aes(x=rosNorm,y=calfprior))+ 
  geom_smooth(aes(group = sim_id),method=&quot;glm&quot;,formula = y~x,method.args = list(family=&#39;binomial&#39;),se=F,linewidth=0.2)</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-8-7.png" width="672" /></p>
<pre class="r"><code>#Parfois, il peut etre bien de regarder les prédiction de variable dérivé 
# et non directement mesurer par le modèle. 
# ici on regarde la somme de bébé produit pour chaque femmelle
# les valeurs prédite s&#39;aligne bien avec celle observé en bleur
prior_df %&gt;%group_by(sim_id,id) %&gt;% summarise(calfprior=sum(calfprior)) %&gt;% 
  ggplot(aes(x=calfprior))+
  stat_density(aes(group = sim_id), position = &quot;identity&quot;, geom = &quot;line&quot;, alpha = 0.3)+
  stat_density(data=data.frame(calfprior=tapply(dat$calf,INDEX = dat$id,FUN = sum)),
               aes(x=calfprior),
               position = &quot;identity&quot;,
               geom = &quot;line&quot;, color=&quot;blue&quot;)+
  coord_cartesian(ylim=c(0,1))</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-8-8.png" width="672" /></p>
<pre class="r"><code>prior_df %&gt;%group_by(sim_id,period) %&gt;% summarise(calfprior=mean(calfprior)) %&gt;% 
   ggplot(aes(x=as.factor(period),y=calfprior))+geom_violin()</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-8-9.png" width="672" /></p>
<p>En raison du grand nombre d’effets estimés et du fait que nous
n’imposons que des contraintes légères sur chaque distribution <em>a
priori</em>, on doit s’attendre à des valeurs extrêmes voire impossibles
(grandes valeurs positives et négatives); l’important est que la densité
soit plus grande dans une plage de valeurs réalistes. Il peut être utile
de faire un “zoom” sur une partie du graphique <code>ggplot</code> en y
ajoutant
<code>coord_cartesian(xlim = c(..., ...), ylim = c(..., ...))</code>
avec des limites en <span class="math inline">\(x\)</span> et <span
class="math inline">\(y\)</span>.</p>
<p><strong>C</strong> Ajustez maintenant le modèle avec
<code>brm</code>. Vous pouvez réduire le nombre de chaînes de Markov à 2
pour sauver du temps, mais conservez les valeurs par défaut pour le
nombre d’itérations. (Vous pouvez ignorer l’avertissement selon lequel
la taille effective de l’échantillon ou ESS est faible.) Comment
pouvez-vous évaluer la convergence du modèle?</p>
<pre class="r"><code>res_br &lt;- brm(calf ~ ages+age2+rosNorm +(rosNorm|period),family=bernoulli(&quot;logit&quot;),
    prior = my_prior,iter = 4000,thin=2,
    data = dat,chains = 2)</code></pre>
<pre class="r"><code># as_draw extrait les postérieur (oui prior) du modèle et 
# les arrange dans un data.frame
post_params &lt;- as_draws_df(res_br)

mcmc_plot(res_br, type = &quot;trace&quot;) # voir les trace plot</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<pre class="r"><code>mcmc_plot(res_br, type = &quot;acf_bar&quot;) # voir l&#39;auto-correlation</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-10-2.png" width="672" /></p>
<pre class="r"><code># voir les estimé des parametre et leurs CI (50 et 95)
mcmc_plot(res_br,variable = &#39;r_period&#39;, type = &quot;intervals&quot;)</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-10-3.png" width="672" /></p>
<pre class="r"><code># il est très informatif de comparer les postérieurs au prior
rbind(
  post_params[,c( &quot;b_Intercept&quot;,&quot;b_ages&quot;,&quot;b_age2&quot;,&quot;b_rosNorm&quot;,
               &quot;sd_period__Intercept&quot;  ,&quot;sd_period__rosNorm&quot;  )] %&gt;% 
  mutate(post=T),
  prior_params[,c( &quot;b_Intercept&quot;,&quot;b_ages&quot;,&quot;b_age2&quot;,&quot;b_rosNorm&quot;,
                &quot;sd_period__Intercept&quot;  ,&quot;sd_period__rosNorm&quot;  )]%&gt;% 
  mutate(post=F)
) %&gt;% pivot_longer(-post) %&gt;% 
  ggplot(aes(x=value))+geom_density(aes(color=post))+facet_wrap(~name,scales = &quot;free_x&quot;)</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-10-4.png" width="672" /></p>
<pre class="r"><code># nous pouvons aussi faire un test de comparaisont des prédictions pposterieur au vrai donnée
pp_check(res_br, type = &quot;stat&quot;, stat = function(x) sum(x == 1))</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-10-5.png" width="672" /></p>
<p><strong>D</strong> Comparez la magnitude du coefficient de
<code>rosNorm</code> à celle des effets aléatoires. Qu’est-ce que cette
comparaison vous apprend?</p>
<pre class="r"><code>summary(res_br)</code></pre>
<pre><code>## Warning: There were 1 divergent transitions after warmup. Increasing
## adapt_delta above 0.8 may help. See
## http://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup</code></pre>
<pre><code>##  Family: bernoulli 
##   Links: mu = logit 
## Formula: calf ~ ages + age2 + rosNorm + (rosNorm | period) 
##    Data: dat (Number of observations: 1922) 
##   Draws: 2 chains, each with iter = 4000; warmup = 2000; thin = 2;
##          total post-warmup draws = 2000
## 
## Group-Level Effects: 
## ~period (Number of levels: 5) 
##                        Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS
## sd(Intercept)              0.48      0.17     0.24     0.88 1.00     1568
## sd(rosNorm)                0.46      0.18     0.20     0.88 1.00     1533
## cor(Intercept,rosNorm)     0.31      0.38    -0.49     0.89 1.00     1363
##                        Tail_ESS
## sd(Intercept)              1818
## sd(rosNorm)                1586
## cor(Intercept,rosNorm)     1633
## 
## Population-Level Effects: 
##           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## Intercept     0.53      0.24     0.05     1.03 1.00     1077     1249
## ages          0.63      0.06     0.52     0.75 1.00     1908     1859
## age2         -0.67      0.05    -0.78    -0.58 1.00     1652     1675
## rosNorm      -0.45      0.20    -0.81    -0.03 1.00     1450     1635
## 
## Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS
## and Tail_ESS are effective sample size measures, and Rhat is the potential
## scale reduction factor on split chains (at convergence, Rhat = 1).</code></pre>
<p><strong>E</strong> Vérifier les prédictions a posteriori: Appliquez
<code>predict</code> au modèle pour obtenir la moyenne, l’écart-type et
l’intervalle à 95% pour la prédiction <em>a posteriori</em>. Vous pouvez
donner un data.frame à l’argument newdata pour obtenir les prédictions
voulues
(<code>expand.grid(rosNorm=seq(-1.6,1.6,l=30),period=unique(dat$period),...)</code>).
Illustrez les prédictions du modèle et leurs intervalles de crédibilité
pour les différentes périodes pour un individu de 7 ans.</p>
<pre class="r"><code># nous faisons la premiere prédiction en changeant l&#39;age pour 0.
# ceci résult en un controle de cette variable inutile dans le graphique
# l&#39;argument re_formula nous permet de controller quel effets aléatoires 
# sont considérer lors de la prédiction.

post_pred &lt;- posterior_epred(res_br,
                              newdata = mutate(dat,ages=0,age2=0),
                              re_formula =~(rosNorm|period))
dat$y=apply(post_pred,2,mean)
dat$y.sd=apply(post_pred,2,sd)
dat$ymin=apply(post_pred,2,function(x) quantile(x,0.025))
dat$ymax=apply(post_pred,2,function(x) quantile(x,0.975))
pt &lt;- dat %&gt;% group_by(period,year) %&gt;% summarise_if(is.numeric,mean)

# nous pouvons aussi partir d&#39;un nouveau data.frame ou
# nous générons une séquence de valeurs de ros allant du minimum au maximum.
# si cette sequence contien assez de point, les relier les un au autre 
# résultera uine une courbe de prédiction
newd=expand.grid(ages=0,age2=0,rosNorm=seq(-1.6,1.6,l=30),period=unique(dat$period),id=&quot;W16&quot;)
post_pred2 &lt;- posterior_epred(res_br,newdata =newd, re_formula =~(rosNorm|period) )
newd$y=apply(post_pred2,2,mean)
newd$y.sd=apply(post_pred2,2,sd)
newd$ymin=apply(post_pred2,2,function(x) quantile(x,0.025))
newd$ymax=apply(post_pred2,2,function(x) quantile(x,0.975))


ggplot(newd,aes(x=rosNorm,y=y))+
  geom_point(data=pt)+
  geom_ribbon(aes(fill=period,ymin=ymin,ymax=ymax),alpha=0.2)+
  geom_path(aes(color=period))</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<pre class="r"><code># on peut recommencer pour l&#39;effet de l&#39;age. en fixant ros à sa
# moyenne (0 puisque normallisé)
post_pred &lt;- posterior_epred(res_br,
                              newdata = mutate(dat,rosNorm=0),
                              re_formula =NA)
dat$y=apply(post_pred,2,mean)
dat$y.sd=apply(post_pred,2,sd)
dat$ymin=apply(post_pred,2,function(x) quantile(x,0.025))
dat$ymax=apply(post_pred,2,function(x) quantile(x,0.975))
pt &lt;- dat %&gt;% group_by(period,age,year) %&gt;% summarise_if(is.numeric,mean)

newd=dat %&gt;% select(age,ages,age2) %&gt;% unique() %&gt;% mutate(rosNorm=0)
post_pred2 &lt;- posterior_epred(res_br,newdata =newd, re_formula =NA)
newd$y=apply(post_pred2,2,mean)
newd$y.sd=apply(post_pred2,2,sd)
newd$ymin=apply(post_pred2,2,function(x) quantile(x,0.025))
newd$ymax=apply(post_pred2,2,function(x) quantile(x,0.975))

ggplot(newd)+
  stat_summary(data=pt,aes(x=age,y=calf),fun.data = &#39;mean_cl_boot&#39;,geom=&#39;pointrange&#39;)+
  geom_ribbon(aes(x=age,y=y,ymin=ymin,ymax=ymax),alpha=0.2)+
  geom_line(aes(x=age,y=y,ymin=ymin,ymax=ymax))</code></pre>
<pre><code>## Warning in geom_line(aes(x = age, y = y, ymin = ymin, ymax = ymax)): Ignoring
## unknown aesthetics: ymin and ymax</code></pre>
<p><img src="09bR-Modeles_bayesiens2_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
