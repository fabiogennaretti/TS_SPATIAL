<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Time series</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.26/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="styles-xar8202.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Time series
]
.date[
### Analysis and Modelling of Time Series and Spatial Data - 2025
]

---




# Course content

- Temporal and spatial dependence

- Properties of time series

- ARIMA models for time series

- Fitting ARIMA models in R

- Forecasting from a model

- Temporal dependence in additive and Bayesian models
    
---

class: inverse, center, middle

# Temporal and spatial dependence

---

# Temporal and spatial dependence

- Observations that are close in time or space are more similar than those that are far apart.

- First law of geography (W. Tobler): "Everything is related to everything else, but near things are more related than distant things."

--

- Autocorrelation: correlation between measurements of the same variable at different times or locations.

---

# Induced or intrinsic dependence

Two types of spatial or temporal dependence for a measured variable `\(y\)`.

--

Induced dependence: due to spatial or temporal dependence of external variables influencing `\(y\)`.

--

- The growth of a plant in year `\(t+1\)` is correlated with that in year `\(t\)` because climate conditions are similar for two consecutive years. 

--

- The abundance of a species is correlated between two nearby sites, because habitat conditions are more similar.

--

If external variables are included in a model for `\(y\)`, the residuals of this model will be independent. 

---

# Induced or intrinsic dependence

Intrinsic dependence: due to a temporal or spatial dependence in the variable `\(y\)` itself.

--

- If a plant grows more in year `\(t\)`, it will have more leaves and roots and will thus be able to extract more resources to grow in year `\(t+1\)`.

--

- The abundance of a species is correlated between two nearby sites due to the dispersal of individuals between populations.

--

An intrinsic dependence cannot be eliminated by adding predictors to the model.

---

# Time or position as predictor

- Example: adding year, longitude or latitude as a predictor in a linear or additive model.

--

- Useful to detect a systematic (linear or not) trend at a large scale.

--

- Different from temporal or spatial correlation in the random fluctuations of a variable (i.e., in the residuals after removing any systematic effect).

---

# Comparison with random effects

- Random effects for the non-independence of grouped data: residual variation correlated among elements of the same group.

--

- Groups often defined by temporal criteria (e.g., same year of observation) or spatial criteria (same site).

--

- Ignores proximity relationships between groups in time or space.

---

# Preview of the next two classes

- This class: time series data at regular intervals (e.g., one measurement per month).

--

- Next class: spatial data, methods also applicable to irregular time series.

---

class: inverse, center, middle

# Properties of time series

---

# R packages used

- *fpp3* package accompanying the textbook by Hyndman and Athanasopoulos, *Forecasting: Principles and Practice*, 3rd edition (https://otexts.com/fpp3/).


``` r
library(fpp3)
```

--

- Loads several other packages related to time series analysis.

---

# Example: Fur trade

- Dataset `pelt`: Number of hare (*Hare*) and lynx furs traded by the Hudson’s Bay Company between 1845 and 1935.


``` r
data(pelt)
head(pelt)
```

```
## # A tsibble: 6 x 3 [1Y]
##    Year  Hare  Lynx
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  1845 19580 30090
## 2  1846 19600 45150
## 3  1847 19610 49150
## 4  1848 11990 39520
## 5  1849 28040 21230
## 6  1850 58000  8420
```

--

- `pelt` is a time series data table or *tsibble*.

---

# Visualizing a time series

- The `autoplot` command applied to a *tsibble* object produces a time plot of the variables specified with `vars`.


``` r
autoplot(pelt, vars(Hare, Lynx))
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

--

- Note that the `\(x\)`-axis indicates the time between each observation, here [1Y] for "1 year".

---

# Visualizing a time series

- This is a `ggplot` type graph that we can customize.


``` r
autoplot(pelt, vars(Hare, Lynx)) +
  labs(x = "Anno", y = "Pelli scambiate")
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

---

# Example: Arctic ice cover


``` r
ice &lt;- read.table("../donnees/sea_ice.txt")
colnames(ice) &lt;- c("year", "month", "day", "ice_km2")
head(ice)
```

```
##   year month day  ice_km2
## 1 1972     1   1 14449000
## 2 1972     1   2 14541400
## 3 1972     1   3 14633900
## 4 1972     1   4 14716100
## 5 1972     1   5 14808500
## 6 1972     1   6 14890700
```

*Source*: Spreen, G., L. Kaleschke, and G. Heygster (2008), Sea ice remote sensing using AMSR-E 89 GHz channels J. Geophys. Res., vol. 113, C02S03, doi:10.1029/2005JC003384.

---

# Example: Arctic ice cover

- Create a date from the *year*, *month*, and *day* columns, convert ice area to million km&lt;sup&gt;2&lt;/sup&gt;, then convert to *tsibble*.

.code60[

``` r
ice &lt;- mutate(ice, date = make_date(year, month, day),
              ice_Mkm2 = ice_km2 / 1E6) %&gt;%
    select(-year, -month, -day, -ice_km2)
ice &lt;- as_tsibble(ice, index = date)
head(ice)
```

```
## # A tsibble: 6 x 2 [1D]
##   date       ice_Mkm2
##   &lt;date&gt;        &lt;dbl&gt;
## 1 1972-01-01     14.4
## 2 1972-01-02     14.5
## 3 1972-01-03     14.6
## 4 1972-01-04     14.7
## 5 1972-01-05     14.8
## 6 1972-01-06     14.9
```
]

---

# Operations on time series data

- *dplyr* operations also apply to *tsibble* with some differences.

--

- `index_by`: Like `group_by`, but used to group rows by time period.

.code60[

``` r
ice &lt;- index_by(ice, month = yearmonth(date)) %&gt;%
    summarize(ice_Mkm2 = mean(ice_Mkm2))
head(ice)
```

```
## # A tsibble: 6 x 2 [1M]
##      month ice_Mkm2
##      &lt;mth&gt;    &lt;dbl&gt;
## 1 1972 Jan     15.4
## 2 1972 Feb     16.3
## 3 1972 Mar     16.2
## 4 1972 Apr     15.5
## 5 1972 May     14.6
## 6 1972 Jun     12.9
```
]

---

# Seasonality

- Variation occurring with a fixed and known period (e.g., week, month, year).


``` r
autoplot(ice)
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-8-1.png)&lt;!-- --&gt;

---

# Seasonality

- Seasonality plot


``` r
gg_season(ice)
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;

---

# Seasonality

- Seasonal subseries plots


``` r
gg_subseries(ice)
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;

---

# Components of a time series

- Trend: Long-term directional change (+ or –, not necessarily linear) of the time series.

--

- Seasonality: Repeated fluctuations with a fixed and known period.

--

- Cycle: Repeated fluctuations with a non-fixed period (e.g., population dynamics, economic cycles).

--

- Noise or residual: Remaining fluctuations after removing previous effects.

---

# Time series decomposition

.pull-left[

- See Chapter 3 of the Hyndman and Athanasopoulos textbook.


``` r
decomp &lt;- model(ice, STL())
autoplot(components(decomp))
```
]

.pull-right[
![](11E-Series_temporelles_files/figure-html/unnamed-chunk-12-1.png)&lt;!-- --&gt;
]

---

# Autocorrelation

- For a time series `\(y\)`, correlation between `\(y_t\)` and `\(y_{t-k}\)` measured at lag `\(k\)`.


``` r
head(ACF(ice))
```

```
## # A tsibble: 6 x 2 [1M]
##        lag     acf
##   &lt;cf_lag&gt;   &lt;dbl&gt;
## 1       1M  0.857 
## 2       2M  0.491 
## 3       3M  0.0263
## 4       4M -0.411 
## 5       5M -0.718 
## 6       6M -0.829
```

---

# Autocorrelation


``` r
autoplot(ACF(ice))
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-14-1.png)&lt;!-- --&gt;

---

# Autocorrelation


``` r
autoplot(ACF(pelt, Lynx))
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-15-1.png)&lt;!-- --&gt;

---

class: inverse, center, middle

# ARIMA models for time series

---

# Stationarity

- A time series is stationary if its statistical properties do not depend on the absolute value of the time variable `\(t\)`.

--

- In other words, these properties are unaffected by any shift of the series in time.

--

- A series with a trend (mean varies with `\(t\)`) is not stationary.

--

- A series with a seasonal component is not stationary.

---

# Stationarity

- A series with a non-seasonal cycle can be stationary. 

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-16-1.png)&lt;!-- --&gt;

---

# Stationarity

- The trend of a time series can be stochastic.

--

- Random walk: `\(y_t = y_{t-1} + \epsilon_t\)` where `\(\epsilon_t \sim \text{N}(0, \sigma)\)`.

--

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-17-1.png)&lt;!-- --&gt;

---

# Differencing 

- The difference between two consecutive values of a random walk is stationary: `\(y_t - y_{t-1} = y_t' = \epsilon_t\)`. 

--

- Here, `\(\epsilon_t\)` is "white noise" (no temporal correlation).

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-18-1.png)&lt;!-- --&gt;

---

# Differencing

- Differencing is a general method for removing a trend from a time series.

--

- First-order difference:

`$$y_t' = y_t - y_{t-1}$$` 

is usually sufficient, but sometimes second order is needed:

`$$y_t'' = (y_t - y_{t-1}) - (y_{t-1} - y_{t-2})$$`

--

- To remove seasonality, we can take the difference between values from the same season.

- Ex.: `\(y_t' = y_t - y_{t-12}\)` for monthly data.

---

# Moving average model

### Example

`$$y_t = \epsilon_t + 0.6 \epsilon_{t-1} + 0.4 \epsilon_{t-2}$$` 

`$$\epsilon_t \sim \text{N}(0, 1)$$`

--

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-19-1.png)&lt;!-- --&gt;

---

# Moving average model

MA(q) model

`$$y_t = \epsilon_t + \theta_1 \epsilon_{t-1} + ... + \theta_q \epsilon_{t-q}$$`

--

- `\(y\)` is the weighted average of the last `\(q+1\)` values of white noise.

--

- The effect of a "shock" `\(\epsilon_t\)` disappears by time `\(t+q+1\)`. Temporal autocorrelation is limited to lag `\(q\)`. 

---

# Moving average model

Example of MA(2) model: `\(y_t = \epsilon_t + 0.6 \epsilon_{t-1} + 0.4 \epsilon_{t-2}\)`

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-20-1.png)&lt;!-- --&gt;

---

# Autoregressive model

- Example: `\(y_t = 0.6 y_{t-1} + \epsilon_t\)`.

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-21-1.png)&lt;!-- --&gt;

---

# Autoregressive model

AR(p) model

`$$y_t = \phi_1 y_{t-1} + ... + \phi_p y_{t-p} + \epsilon_t$$`

--

- `\(y_t\)` is a function of the `\(p\)` previous values, plus white noise.

--

- The `\(\phi\)` coefficients must be `\(&lt;1\)` for a stationary series.

--

- Autocorrelation is present beyond lag `\(p\)`, but the effect fades over time.

- For example: for AR(1), `\(y_t\)` depends on `\(y_{t-1}\)`, and `\(y_{t-1}\)` depends on `\(y_{t-2}\)`, so `\(y_t\)` indirectly depends on `\(y_{t-2}\)`.

---

# Autoregressive model

- Example of AR(1) model: `\(y_t = 0.6 y_{t-1} + \epsilon_t\)`.

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-22-1.png)&lt;!-- --&gt;

---

# Partial autocorrelation

- Correlation between `\(y_t\)` and `\(y_{t-k}\)` after accounting for the effect of lags less than `\(k\)`.

--

.pull-left[
- Use `PACF` function instead of `ACF`.


``` r
plot_grid(autoplot(ACF(ar1_sim)), 
          autoplot(PACF(ar1_sim)))
```
]

--

.pull-right[
![](11E-Series_temporelles_files/figure-html/unnamed-chunk-24-1.png)&lt;!-- --&gt;
]

---

# ARIMA model

- Acronym for *autoregressive integrated moving average model*

--

- ARIMA(p,d,q): Combination of an autoregressive model of order `\(p\)` and a moving average of order `\(q\)` on the variable `\(y\)` differenced `\(d\)` times.

--

- Ex.: ARIMA(pdq(1,1,2))

`$$y'_t = c + \phi_1 y'_{t-1} + \epsilon_t + \theta_1 \epsilon_{t-1} + \theta_2 \epsilon_{t-2}$$`

--

- There are seasonal ARIMA models (not covered in this course).

---

# Regression with correlated residuals

- Example: `\(y_t = \beta_0 + \beta_1 x_{t} + \eta_t\)`

--

- The residual `\(\eta_t\)` follows an ARIMA model.

--

- Depending on the phenomenon to model, it may be useful to difference `\(y\)` and `\(x\)`, or to model `\(y\)` based on past values of `\(x\)` (lag effect).

---

class: inverse, center, middle

# ARIMA models in R: Example 1

---

# Lynx pelts traded at the CBH


``` r
pelt &lt;- mutate(pelt, Lynx = Lynx / 1000)
autoplot(pelt, Lynx)
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-25-1.png)&lt;!-- --&gt;

---

# Choosing the ARIMA model

- The unitroot_ndiffs function performs a statistical test to determine the number of differences needed to obtain a stationary series.

--


``` r
unitroot_ndiffs(pelt$Lynx)
```

```
## ndiffs 
##      0
```

- No differencing required.

---

# Choosing the ARIMA model

- If the data follow an autoregressive model of order `\(p\)`, the partial autocorrelation (PACF) becomes insignificant for lags `\(&gt;p\)`.

--

- If the data follow a moving average model of order `\(q\)`, the autocorrelation (ACF) becomes insignificant for lags `\(&gt;q\)`.

--

- For a model combining AR and MA, it's hard to deduce `\(p\)` and `\(q\)` graphically.

---

# ACF and PACF

- An AR(2) model could be sufficient here.


``` r
plot_grid(autoplot(ACF(pelt, Lynx)), autoplot(PACF(pelt, Lynx)))
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-27-1.png)&lt;!-- --&gt;

---

# Fit an ARIMA model

- `model` function from the *fable* package allows fitting different time series models.

--


``` r
lynx_ar2 &lt;- model(pelt, ARIMA(Lynx ~ pdq(2,0,0)))
```

--

- `ARIMA(Lynx ~ pdq(2,0,0))` specifies an AR(2) model `\((p = 2, d = 0, q = 0)\)`.

--

- `ARIMA` estimates model coefficients by maximum likelihood.

---

# Model summary


``` r
report(lynx_ar2)
```

```
## Series: Lynx 
## Model: ARIMA(2,0,0) w/ mean 
## 
## Coefficients:
##          ar1      ar2  constant
##       1.3446  -0.7393   11.0927
## s.e.  0.0687   0.0681    0.8307
## 
## sigma^2 estimated as 64.44:  log likelihood=-318.39
## AIC=644.77   AICc=645.24   BIC=654.81
```

---

# Automatic model selection


``` r
lynx_arima &lt;- model(pelt, ARIMA(Lynx))
```

--

- If `pdq(...)` is not specified, `ARIMA` automatically chooses the number of differences `\(d\)` using `unitroot_ndiffs`, then chooses `\(p\)` and `\(q\)` values minimizing AIC with a *stepwise* method.

---

# Automatic model selection


``` r
report(lynx_arima)
```

```
## Series: Lynx 
## Model: ARIMA(2,0,1) w/ mean 
## 
## Coefficients:
##          ar1      ar2      ma1  constant
##       1.4851  -0.8468  -0.3392   10.1657
## s.e.  0.0652   0.0571   0.1185    0.5352
## 
## sigma^2 estimated as 60.92:  log likelihood=-315.39
## AIC=640.77   AICc=641.48   BIC=653.33
```

---

# Diagnostic plots


``` r
gg_tsresiduals(lynx_arima)
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-32-1.png)&lt;!-- --&gt;

---

# Fitted vs. observed values


``` r
autoplot(pelt, Lynx) +
  autolayer(fitted(lynx_arima), linetype = "dashed")
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-33-1.png)&lt;!-- --&gt;

---

# Forecasts


``` r
prev_lynx &lt;- forecast(lynx_arima, h = 10)
head(prev_lynx)
```

```
## # A fable: 6 x 4 [1Y]
## # Key:     .model [1]
##   .model       Year       Lynx .mean
##   &lt;chr&gt;       &lt;dbl&gt;     &lt;dist&gt; &lt;dbl&gt;
## 1 ARIMA(Lynx)  1936  N(37, 61)  37.4
## 2 ARIMA(Lynx)  1937 N(36, 141)  35.7
## 3 ARIMA(Lynx)  1938 N(32, 185)  31.5
## 4 ARIMA(Lynx)  1939 N(27, 191)  26.7
## 5 ARIMA(Lynx)  1940 N(23, 196)  23.2
## 6 ARIMA(Lynx)  1941 N(22, 223)  22.0
```

---

# Forecasts


``` r
autoplot(prev_lynx, pelt, level = c(50, 95))
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-35-1.png)&lt;!-- --&gt;

---

class: inverse, center, middle

# ARIMA models in R: Example 2

---

# Electricity demand in the state of Victoria


``` r
data(vic_elec)
head(vic_elec)
```

```
## # A tsibble: 6 x 5 [30m] &lt;Australia/Melbourne&gt;
##   Time                Demand Temperature Date       Holiday
##   &lt;dttm&gt;               &lt;dbl&gt;       &lt;dbl&gt; &lt;date&gt;     &lt;lgl&gt;  
## 1 2012-01-01 00:00:00  4383.        21.4 2012-01-01 TRUE   
## 2 2012-01-01 00:30:00  4263.        21.0 2012-01-01 TRUE   
## 3 2012-01-01 01:00:00  4049.        20.7 2012-01-01 TRUE   
## 4 2012-01-01 01:30:00  3878.        20.6 2012-01-01 TRUE   
## 5 2012-01-01 02:00:00  4036.        20.4 2012-01-01 TRUE   
## 6 2012-01-01 02:30:00  3866.        20.2 2012-01-01 TRUE
```

- Electricity demand in MW recorded every half hour as a function of temperature. 

---

# Data transformation

- Daily aggregation and definition of workdays.


``` r
vic_elec &lt;- index_by(vic_elec, Date) %&gt;%
  summarize(Demand = sum(Demand), Tmean = mean(Temperature),
            Holiday = any(Holiday)) %&gt;%
  mutate(Workday = (!Holiday) &amp; (wday(Date) %in% 2:6))
```

--

- Convert demand to GW.


``` r
vic_elec &lt;- mutate(vic_elec, Demand = Demand / 1000)
```

---

# Data visualization


``` r
ggplot(vic_elec, aes(x = Tmean, y = Demand, color = Workday)) +
  geom_point() +
  scale_color_brewer(palette = "Dark2")
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-39-1.png)&lt;!-- --&gt;

---

# Linear regression model

.code60[

``` r
elec_lm &lt;- lm(Demand ~ Tmean + I(Tmean^2) + Workday, vic_elec)

ggplot(vic_elec, aes(x = Tmean, y = Demand, color = Workday)) +
  geom_point(alpha = 0.3) +
  geom_line(aes(y = fitted(elec_lm))) +
  scale_color_brewer(palette = "Dark2")
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-40-1.png)&lt;!-- --&gt;
]

---

# Correlated residuals


``` r
ggplot(vic_elec, aes(x = Date, y = residuals(elec_lm), color = Workday)) +
  geom_point() +
  scale_color_brewer(palette = "Dark2")
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-41-1.png)&lt;!-- --&gt;

---

# ARIMA model

.code60[

``` r
elec_arima &lt;- model(vic_elec, ARIMA(Demand ~ Tmean + I(Tmean^2) + Workday + PDQ(0,0,0)))
```
]

- `PDQ(0,0,0)` (à ne pas confondre avec `pdq`) spécifie qu'il n'y a pas de composante saisonnière.

--

.code60[

``` r
report(elec_arima)
```

```
## Series: Demand 
## Model: LM w/ ARIMA(1,1,4) errors 
## 
## Coefficients:
##           ar1     ma1      ma2      ma3      ma4     Tmean  I(Tmean^2)
##       -0.7906  0.3727  -0.4266  -0.1977  -0.1488  -11.9062      0.3692
## s.e.   0.0941  0.0989   0.0481   0.0407   0.0284    0.3775      0.0096
##       WorkdayTRUE
##           32.7278
## s.e.       0.4453
## 
## sigma^2 estimated as 46.14:  log likelihood=-3647.85
## AIC=7313.7   AICc=7313.87   BIC=7358.69
```
]

---

# Diagnostic plots


``` r
gg_tsresiduals(elec_arima)
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-44-1.png)&lt;!-- --&gt;

---

# Forecasts


``` r
prev_df &lt;- new_data(vic_elec, 14) %&gt;%
  mutate(Tmean = 20, Workday = TRUE)

head(prev_df)
```

```
## # A tsibble: 6 x 3 [1D]
##   Date       Tmean Workday
##   &lt;date&gt;     &lt;dbl&gt; &lt;lgl&gt;  
## 1 2015-01-01    20 TRUE   
## 2 2015-01-02    20 TRUE   
## 3 2015-01-03    20 TRUE   
## 4 2015-01-04    20 TRUE   
## 5 2015-01-05    20 TRUE   
## 6 2015-01-06    20 TRUE
```

---

# Forecasts


``` r
prev_elec &lt;- forecast(elec_arima, new_data = prev_df)
autoplot(prev_elec, vic_elec) +
  coord_cartesian(xlim = c(as_date("2014-11-01"), as_date("2015-01-15")))
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-46-1.png)&lt;!-- --&gt;

---

# R function summary

- `as_tsibble(..., index = ...)`: Convert to *tsibble*.

- `index_by`: Group a *tsibble* for temporal aggregation.
 
--
 
- `ACF` and `PACF`

--

- `model`: Create a time series model.

- `ARIMA(y ~ x + pdq(...) + PDQ(...))`

--

- `forecast(mod, h = ...)` or `forecast(mod, new_data = ...)`

--

- Plots: `autoplot` (tsibble, ACF/PACF, forecast), `gg_season` et `gg_subseries`, `gg_tsresiduals`.

---

# Reference

Hyndman, R.J. et Athanasopoulos, G. (2019) Forecasting: principles and practice, 3e édition, OTexts: Melbourne, Australia. http://OTexts.com/fpp3. (surtout les chapitres 2 à 5, 9 et 10).

---

class: inverse, center, middle

# Additive and Bayesian models with temporal correlations

---

# Multiple time series

- In previous examples, all data came from the same time series.

--

- It is common to want to fit the same model (same parameters) to multiple independent time series.

- Ex.: growth of multiple trees of the same species, abundance of a species at several sites.

--

- A temporal data table (*tsibble*) may contain multiple time series, but in this case the `ARIMA` model is fit separately to each series.

---

# Multiple time series

- In this section: how to add ARMA-type temporal correlation to the residuals of a GAM (with *mgcv*) or a Bayesian hierarchical model (with *brms*). 

--

- No automatic selection of `\(p\)` and `\(q\)`.

--

- No differencing (the I in ARIMA), but residuals should be stationary and any trend should be included in the main model.

---

# Example: Dendrochronological series

- Dendrochronological series of 23 *Abies amabilis* (dataset `wa082` from the *dplr* package).

--

- Basal area increment (*cst*) as a function of basal area (*st*) and tree age.


```
## # A tibble: 6 × 5
##   annee id_arbre   cst   age     st
##   &lt;int&gt; &lt;fct&gt;    &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt;
## 1  1811 X712011   7.35     1   7.35
## 2  1812 X712011  19.2      2  26.6 
## 3  1813 X712011  32.3      3  58.9 
## 4  1814 X712011  48.6      4 108.  
## 5  1815 X712011  58.5      5 166.  
## 6  1816 X712011  67.4      6 233.
```

---

# Additive growth model

- Fixed effects of basal area and age, random effect of tree.


``` r
library(mgcv)
gam_wa &lt;- gam(log(cst) ~ log(st) + s(age) + s(id_arbre, bs = "re"), data = wa)
plot(gam_wa, pages = 1)
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-48-1.png)&lt;!-- --&gt;

---

# Alternative function to fit a GAMM

- The `gamm` function specifies random effects differently, based on the `lme` function from the *nlme* package.


``` r
gam_wa2 &lt;- gamm(log(cst) ~ log(st) + s(age), data = wa,
                random = list(id_arbre = ~1))
gam_wa2$lme
```


---

# Alternative function to fit a GAMM

.code50[

```
## Linear mixed-effects model fit by maximum likelihood
##   Data: strip.offset(mf) 
##   Log-likelihood: -1958.017
##   Fixed: y ~ X - 1 
## X(Intercept)     Xlog(st)   Xs(age)Fx1 
##   -2.8430849    0.8926357    3.6526718 
## 
## Random effects:
##  Formula: ~Xr - 1 | g
##  Structure: pdIdnot
##              Xr1      Xr2      Xr3      Xr4      Xr5      Xr6      Xr7      Xr8
## StdDev: 5.359563 5.359563 5.359563 5.359563 5.359563 5.359563 5.359563 5.359563
## 
##  Formula: ~1 | id_arbre %in% g
##         (Intercept)  Residual
## StdDev:   0.1834672 0.3666839
## 
## Number of Observations: 4536
## Number of Groups: 
##               g id_arbre %in% g 
##               1              23
```
]

---

# Adding a temporal correlation

- `corAR1(form = ~ 1 | id_arbre)`: Means residuals of the same tree are correlated according to an AR(1) model.


``` r
gam_wa_ar &lt;- gamm(log(cst) ~ log(st) + s(age), data = wa,
                  random = list(id_arbre = ~1), 
                  correlation = corAR1(form = ~ 1 | id_arbre))
```

---

# Adding a temporal correlation

.code50[

```
## Linear mixed-effects model fit by maximum likelihood
##   Data: strip.offset(mf) 
##   Log-likelihood: -567.5418
##   Fixed: y ~ X - 1 
## X(Intercept)     Xlog(st)   Xs(age)Fx1 
##   -2.6964027    0.8779548    3.3712324 
## 
## Random effects:
##  Formula: ~Xr - 1 | g
##  Structure: pdIdnot
##             Xr1     Xr2     Xr3     Xr4     Xr5     Xr6     Xr7     Xr8
## StdDev: 4.92288 4.92288 4.92288 4.92288 4.92288 4.92288 4.92288 4.92288
## 
##  Formula: ~1 | id_arbre %in% g
##         (Intercept)  Residual
## StdDev:   0.1718674 0.3730067
## 
## Correlation Structure: AR(1)
##  Formula: ~1 | g/id_arbre 
##  Parameter estimate(s):
##       Phi 
## 0.6870206 
## Number of Observations: 4536
## Number of Groups: 
##               g id_arbre %in% g 
##               1              23
```
]

---

# Spline estimation


``` r
par(mfrow = c(1, 2))
plot(gam_wa2$gam, select = 1, main = "GAMM")
plot(gam_wa_ar$gam, select = 1, main = "GAMM AR(1)")
```

![](11E-Series_temporelles_files/figure-html/unnamed-chunk-53-1.png)&lt;!-- --&gt;

---

# Other options with `gamm` and `lme`

- `corARMA` for a more general model.

- Example: `correlation = corARMA(form = ~ 1 | id_arbre, p = 2, q = 1)` for AR(2), MA(1).

--

- `lme` (package *nlme*) provides the same functionality for linear mixed models, with the same `random` and `correlation` arguments.

---

# Limitations of `gamm` and `lme`

- Not suitable for generalized models (non-normal residuals).

--

- Cannot include multiple non-nested random effects.

--

- Bayesian models (with *brms*) offer the most flexible option for combining random effects and temporal correlations.

---

# Bayesian version of the model

- Add term `ar(p = 1, gr = id_arbre)`: AR(1) correlation within groups defined by *id_arbre*.


``` r
library(brms)

wa_br &lt;- brm(log(cst) ~ log(st) + s(age) + (1 | id_arbre) + ar(p = 1, gr = id_arbre), 
             data = wa, chains = 2)
```






--

- Other options: `ma(q = ...)`, `arma(p = ..., q = ...)`.

--

- In this example, we let `brms` choose default *prior* distributions.

---

# Model results

.code50[

``` r
summary(wa_br)
```
]

---

# Visualize spline


``` r
marginal_smooths(wa_br)
```

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
